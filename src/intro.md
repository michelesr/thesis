# Introduction 

My collaboration with the *beFair* software development team begins at the firsts months of this year, when the team realized that a boost in the quality of the development process and final product could be obtained with the application of automated software testing. Testing help discover bugs, and contribute to the increment of the software quality, and in particular, the tests suite is itself a quality indicator. There are different typologies of tests to implement, and part of this work is to compare them and find the most suitable and urgent for team projects.

As the title suggest, this work will focus on *end-to-end* tests. End-to-end testing is the testing of the final product, and his purpose is to simulate in a programmatic way the user interaction with the application interface in order to discover bugs that are visible from the external, the same bugs the users discover first, thus the most urgent. End-to-end testing for web applications involves system to drive different web browser in order to make them interact with the application and ensure that its function are working properly.

At the same time, our team decided to change the way application are deployed and developed, from traditional approach, to a container based one. Containers are isolated environment where an application resides, and container can communicate to each other using a virtual network provided by the container engine, which is also the software that creates and manage them. A container based approach leads to different advantages, in particular for the production, where provides scalability, reliability, automation, better management, and rolling updates. For the developers, containers can be used to obtain a development environment similar to the production one, eliminating the disadvantages arising from the differences between these two environments, such as bug related to different version of an application components, or related to difference between the web server used in the environments. Regard the testing of the software, there is a series of steps to perform in order to adapt the testing process to the container based architecture, but this architecture provides a standardized testing environment that is completely reproducible. Often developers doesn't run integration and end-to-end tests on his desktop or laptop machines because they don't want to configure the testing environment, or a different configuration can lead to different tests result. This work will cover the aspects of integrating the container approach to the testing of the software, and provide a simple procedure to run all the implemented tests without effort for the developers.

Tests can run in the developer machines, but it is important that also run in a continuous integration environment. Once the code is pushed to a *SCM* (Source Code Management) system, a hook for automated tests has to be run (continuous integration), and if the tests pass, then the application must be automatically deployed (continuous delivery). If the tests don't pass, the deploy abort and developers have to be warned about the critical situation.

## Organization

Chapter 2 will expose the technological context that leads to the thesis work, and the economical social context of team which I collaborated.

Chapter 3 exhibits the main typologies of automatic tests with related examples, starting from unit tests, going through integration tests and finally introducing the end-to-end tests.

Chapter 4 talks about how Docker container engine and *Docker Compose* @docker-compose can be used to easily reproduce an environment similar to the one deployed in production in order to make developers life better, and the main advantages of this approach compared to the use of *Vagrant* @vagrant. This chapter will also expose the motivation that leads to the choice of those instruments and will show the architecture of the software that will be tested.

Chapter 5 shows the main tools used in end-to-end tests and how to configure the testing framework to work with the container ecosystem. The configuration is an integral part of this thesis and aims to reduce the developer effort to get the testing environment.

Chapter 6 will cover the end-to-end test techniques used to ensure a better quality of the tested software. In particularly *AngularJS* @angularjs applications will be tested using *Protractor* @protractor testing framework. Testing often reveals bad design choice made during the development process, so this chapter will also give some advice to how to write a better software and better tests.

Chapter 7 will explain how to build a Continuous Integration system to provide automatic run of tests once the code is updated and pushed into the project repository. Continuous integration is essential for continuous delivery and rolling release of the software products.
